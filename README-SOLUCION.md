# Solución

En los siguientes párrafos voy a describir brevement la solución que he implementado para el coding challenge de idealista, explicando las ventajas del enfoque seleccionado. También comentaré aspectos que podrían ser alterados o mejorados.

El problema principal a resolver es la asignación de un score a cada anuncio. A nivel algorítmico el problema es trivial, pero a nivel arquitectural se puede plantear una solución que permita extender o reducir con facilidad la cantidad de checks que se quiere hacer sobre un anuncio. También se puede buscar que la configuración necesaria para estos checks sea fácil de cambiar así como extensible y sin la necesidad de recompilar el código. 

Para lograr este objetivo, he decido crear una interfaz funcional `AdScorer` con el método `getScore(Ad ad)`. Esta interfaz recibe un anuncio como parámetro y devuelve un score como resultado de un check (a discreción de la implementación). De esta manera, podemos utilizar la potencia del contendor de inyección de dependencias de spring para inicializar una lista de todas las implementaciones de esta interfaz, `List<AdScorer>`, pudiendo simplemente iterar la lista y realizar una reducción para calcular el score total de un anuncio. Añadir un nuevo check solo requiere crear una nueva implementación de la interfaz, y borrar un check solo requiere borrar la implementación correspondiente (o quitar la anotación `@Component` si se quieren desactivar temporalmente sin modificar la lógica).

Por otra parte, cada implementación de AdScorer puede tener una configuración a partir de la cual obtener sus parámetros y el score de recompensa. Dicha configuración se encuentra en el fichero `application.yml`. Por ejemplo, si se desean introducir más rangos a la cantidad de palabras de la descripción, bastaría con introducir una nueva entrada en la lista de la tipología correspondiente en la propiedad `ads.description.word-ranges`.

Esta solución es muy escalable permitiendo extender o reducir la cantidad de checks con un mínimo de esfuerzo y permitiendo cambiar la configuración (en un caso real con spring configuration) sin necesidad de recompilar la aplicación.

Además, este enfoque simplifica la creación de tests unitarios. Dado que los checks son independientes entre sí, solo bastante con crear tests unitarios para cada implementación de la interfaz sin necesidad de crear un test de integración que ejecute todos los checks. Esto es posible porque son los checks son independientes. Si hubiera alguna característica como el orden de ejecución dejarían de ser independientes y tendría que crearse un test de integración. Y como comentaba antes, dada la potencia del contenedor, la creación de dicho test sería relativamente sencilla.

En cuanto a la paquetización, he estructurado los paquetes por dominio / caso de uso / capa. Es decir, el dominio es Ad, el caso de uso es score o search, y la capa sería controller, service, etc. Además, para adaptar la capa de persistencia y la de dominio (para poder contar con Ads con Pictures en vez de solo PicturesIds) he creado un adaptador que simula el comportamiendo de un ORM (hace el equivalente a un join entre ad y pictures por adId).