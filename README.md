# Solución

En los siguientes párrafos voy a describir brevement la solución que he implementado para el coding challenge de idealista, explicando las ventajas del enfoque seleccionado. También comentaré aspectos que podrían ser alterados o mejorados.

El problema principal a resolver es la asignación de un score a cada anuncio. A nivel algorítmico el problema es trivial, pero a nivel arquitectural se puede plantear una solución que permita extender o reducir con facilidad la cantidad de checks que se quiere hacer sobre un anuncio. También se puede buscar que la configuración necesaria para estos checks sea fácil de cambiar así como extensible y sin la necesidad de recompilar el código. 

Para lograr este objetivo, he decido crear una interfaz funcional `AdScorer` con el método `getScore(Ad ad)`. Esta interfaz recibe un anuncio como parámetro y devuelve un score como resultado de un check (a discreción de la implementación). De esta manera, podemos utilizar la potencia del contendor de inyección de dependencias de spring para inicializar una lista de todas las implementaciones de esta interfaz, `List<AdScorer>`, pudiendo simplemente iterar la lista y realizar una reducción para calcular el score total de un anuncio. Añadir un nuevo check solo requiere crear una nueva implementación de la interfaz, y borrar un check solo requiere borrar la implementación correspondiente (o quitar la anotación `@Component` si se quieren desactivar temporalmente sin modificar la lógica).

Por otra parte, cada implementación de AdScorer puede tener una configuración a partir de la cual obtener sus parámetros y el score de recompensa. Dicha configuración se encuentra en el fichero `application.yml`. Este enfoque permite cambiar la configuración sin necesidad de recompilar la aplicación. Por ejemplo, si se desean introducir más rangos a la cantidad de palabras de la descripción, bastaría con introducir una nueva entrada en la lista de la tipología correspondiente en la propiedad `ads.description.word-ranges`.
Esta solución es muy escalable permitiendo extender o reducir la cantidad de checks con un mínimo de esfuerzo y permitiendo cambiar la configuración (en un caso real con spring configuration) sin necesidad de recompilar la aplicación.

Además, este enfoque simplifica la creación de tests unitarios. Dado que los checks son independientes entre sí, solo bastaría con crear tests unitarios para cada implementación de la interfaz sin necesidad de crear un test de integración que ejecute todos los checks. Esto es posible porque son los checks son independientes. Si hubiera alguna característica como el orden de ejecución dejarían de ser independientes y tendría que crearse un test de integración. Y como comentaba antes, dada la potencia del contenedor, la creación de dicho test sería relativamente sencilla.

En cuanto a la paquetización, he estructurado los paquetes por dominio / caso de uso / capa. Es decir, el dominio es Ad, el caso de uso es score o search, y la capa sería controller, service, etc. Además, para adaptar la capa de persistencia y la de dominio (para poder contar con Ads con Pictures en vez de solo PicturesIds) he creado un adaptador que simula el comportamiendo de un ORM (hace el equivalente a un join entre ad y pictures por adId).

## Endpoints
Una vez levantada, la app expone 3 endpoints.
   * GET http://localhost:8080/ads?quality={"IRRELEVANT"|"RELEVANT"|"NOT_SCORED"}
     * Devuelve todos los anuncios de la calidad proporcionada o si no se proporciona ninguna calidad devuelve todos los anuncios. En el caso de los anuncios de tipo RELEVANT, los devuelve ordenados descendientemente por score. El orden en el resto de casos es por id.
   * GET http://localhost:8080/ads/{adId}
     * Devuelve el anuncio con el id dado. (Por conveniencia)
   * POST http://localhost:8080/scores
     * Calcula los scores para todos los Ads y persiste el resultado en memoria. Los ads tendrán score mientras la app siga levantada. Una vez que se reinicia se tiene que volver a invocar a este método para recalcular los scores. En este caso estoy usando un POST puesto que la operación crea un nuevo recurso en la colección de ads. En este caso me gustaría comentar que no estoy del todo convencido con la ruta usada. En cualquier caso /ads/scores no se puede usar puesto que ya existe /ads/{adId} y generaría ambigüedad en la resolución de rutas. 
    
Cabe comentar que en un caso real, una solución más apropiada sería calcular el score de un anuncio cuando este se cree o modifique, sin necesidad de exponer un endpoint para calcular dichos scores. Es posible que si se usasen distintos roles para el gestor de la calidad y el usuario (que debiera), entonecs un único endpoint no sería apropiado y debieran separarse en dos. Uno que no admitiera parámetros /public/ads y otro que admitiera parámetros /internal/ads (por poner un ejemplo).